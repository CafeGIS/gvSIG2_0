/* DielmoOpenLiDAR
 *
 * Copyright (C) 2008 DIELMO 3D S.L. (DIELMO) and Infrastructures
 * and Transports Department of the Valencian Government (CIT)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA  02110-1301, USA.
 *
 * For more information, contact:
 *
 * DIELMO 3D S.L.
 * Plaza Vicente Andrés Estellés 1 Bajo E
 * 46950 Xirivella, Valencia
 * SPAIN
 *
 * +34 963137212
 * dielmo@dielmo.com
 * www.dielmo.com
 *
 * or
 *
 * Generalitat Valenciana
 * Conselleria d'Infraestructures i Transport
 * Av. Blasco Ibáñez, 50
 * 46010 VALENCIA
 * SPAIN
 *
 * +34 963862235
 * gvsig@gva.es
 * www.gvsig.gva.es
 */

/*
 * AUTHORS (In addition to DIELMO and CIT):
 *
 */

package com.dielmo.lidar;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public abstract class LASHeader_1X implements LidarHeader{

	/**
	 * path of LAS file
	 */
	protected File m_Fich;

	/**
	 * file Signature, must contain LASF
	 */
	protected char[] fileSignature = new char[4];

	/**
	 * Global Unique IDentifier 1; unsigned int
	 */
	protected long GUID1 ;

	/**
	 * Global Unique IDentifier 2; unsigned short
	 */
	protected int GUID2 ;

	/**
	 * Global Unique IDentifier 3; unsigned short
	 */
	protected int GUID3 ;

	/**
	 * Global Unique IDentifier 4
	 */
	protected char[]GUID4 = new char[8];

	/**
	 * version format number mayor
	 */
	protected char versionMayor;

	/**
	 * version format number minor
	 */
	protected char versionMinor;

	/**
	 * software generated by: Original Data, Merge, Modification, Extraction, Transformation or Other
	 */
	protected char[] systemIDentifier = new char[32];

	/**
	 * Who generate software
	 */
	protected char[] generatingSoftware = new char[32];

	/**
	 * LAS 1.0 Julian day
	 * LAS 1.1 day of year 1-365
	 */
	protected int day;

	/**
	 * In LAS 1.0 year that the data was collected.
	 * In LAS 1.1 year on which this file was created.
	 */
	protected int year;

	/**
	 * Size, in bytes, of the header file
	 */
	protected int hdrSize;

	/**
	 * Number of bytes from the beginning of the file
	 * to the first point record data (including the two
	 * bytes for data start signature in case of LAS1.0).
	 */
	protected long offsetData;

	/**
	 * number of variable length records
	 */
	protected long numVarLengthRecord;

	/**
	 * point data record format type (0-1)
	 */
	protected char pointDataFormatID;

	/**
	 * size of the point data record
	 */
	protected int pointDataRecordLength;

	/**
	 * total number of points records within the file
	 */
	protected long numPointsRecord;

	/**
	 * array of the total point records per return
	 */
	protected long[] numPointsByReturn = new long[5];

	/**
	 * X Scale factor for scale corresponding X values within the point
	 * record.
	 */
	protected double xScale;

	/**
	 * Y Scale factor for scale corresponding Y values within the point
	 * record.
	 */
	protected double yScale;

	/**
	 * Z Scale factor for scale corresponding Z values within the point
	 * record.
	 */
	protected double zScale;

	/**
	 * X Offset used to set the overall offset for the point records.
	 */
	protected double xOffset;

	/**
	 * Y Offset used to set the overall offset for the point records.
	 */
	protected double yOffset;

	/**
	 * Z Offset used to set the overall offset for the point records.
	 */
	protected double zOffset;

	/**
	 * The actual maximum X of coordinate extents of the file
	 */
	protected double maxX;

	/**
	 * The actual minimum X of coordinate extents of the file
	 */
	protected double minX;

	/**
	 * The actual maximum Y of coordinate extents of the file
	 */
	protected double maxY;

	/**
	 * The actual minimum Y of coordinate extents of the file
	 */
	protected double minY;

	/**
	 * The actual maximum Z of coordinate extents of the file
	 */
	protected double maxZ;

	/**
	 * The actual minimum Z of coordinate extents of the file
	 */
	protected double minZ;

	/**
	 * Default constructor, without arguments.
	 * Initializes all components to zero.
	 */
	public LASHeader_1X(File file) {
		m_Fich = file;
		int i;

		fileSignature[0] = 'L';
		fileSignature[1] = 'A';
		fileSignature[2] = 'S';
		fileSignature[3] = 'F';

		GUID1 = 0;
		GUID2 = 0;
		GUID3 = 0;

		for(i=0;i<8;i++) {
			GUID4[i] = 0;
		}

		versionMayor = 0;
		versionMinor = 0;

		for(i=0;i<32;i++) {
			systemIDentifier[i] = 0;
		}

		for(i=0;i<32;i++) {
			generatingSoftware[i] = 0;
		}

		generatingSoftware[0] = 'D';
		generatingSoftware[1] = 'I';
		generatingSoftware[2] = 'E';
		generatingSoftware[3] = 'L';
		generatingSoftware[4] = 'M';
		generatingSoftware[5] = '0';
		generatingSoftware[6] = ' ';
		generatingSoftware[7] = '3';
		generatingSoftware[8] = 'D';
		generatingSoftware[9] = ' ';
		generatingSoftware[10] = 'S';
		generatingSoftware[11] = '.';
		generatingSoftware[12] = 'L';
		generatingSoftware[13] = '.';

		day = 0;
		year = 0;
		hdrSize=227;
		offsetData=0;
		numVarLengthRecord=0;
		pointDataFormatID=0;
		pointDataRecordLength=0;
		numPointsRecord=0;

		for(i=0;i<5;i++) {
			numPointsByReturn[i] = 0;
		}

		xScale=0;
		yScale=0;
		zScale=0;
		xOffset=0;
		yOffset=0;
		zOffset=0;
		maxX=0;
		minX=0;
		maxY=0;
		minY=0;
		maxZ=0;
		minZ=0;
	}

	// GET MEHODS
	/**
	 * Return file signature. This must be always "LASF"
	 *
	 * @return String with file signature
	 */
	public String getFileSignature() {

		String f = new String(fileSignature);
		// comprobamos los datos y si son nulos se ponen a cero
		return f;
	}

	/**
	 * Return Global unique identifier 1 (GUID1)
	 *
	 * @return GUID1
	 */
	public long getGUID1() {
		return GUID1;
	}

	/**
	 * Return Global unique identifier 2 (GUID2)
	 *
	 * @return GUID2
	 */
	public int getGUID2() {
		return GUID2;
	}

	/**
	 * Return Global unique identifier 3 (GUID3)
	 *
	 * @return GUID3
	 */
	public int getGUID3() {
		return GUID3;
	}

	/**
	 * Return Global unique identifier 4 (GUID4)
	 *
	 * @return String with GUID4
	 */
	public String getGUID4() {
		String G4;
		char[] G = new char[8];
		int i;
		for(i=0;i<8;i++) {

			if(GUID4[i]!=0) {
				G[i] = GUID4[i];
			} else {
				G[i] = ' ';
			}
		}

		G4 = new String(G);
		return G4;
	}

	/**
	 * Return LAS version mayor of the file
	 *
	 * @return version mayor
	 */
	public char getVersionMayor() {
		return versionMayor;
	}

	/**
	 * Return LAS version minor of the file
	 *
	 * @return version minor
	 */
	public char getVersionMinor() {
		return versionMinor;
	}

	/**
	 * Return software generated by: Original Data, Merge, Modification, Extraction, Transformation or Other
	 *
	 * @return String with System identifier
	 */
	public String getSystemIDentifier() {
		String SysID;
		char[] S = new char[32];
		int i;
		for(i=0;i<32;i++) {

			if(systemIDentifier[i]!=0) {
				S[i] = systemIDentifier[i];
			} else {
				S[i] = ' ';
			}
		}

		SysID = new String(S);
		return SysID;
	}

	/**
	 * Return who generates software
	 *
	 * @return String with generates software
	 */
	public String getGeneratingSoftware() {
		String GenSoftware;
		char[] G = new char[32];
		int i;
		for(i=0;i<32;i++) {

			if(generatingSoftware[i]!=0) {
				G[i] = generatingSoftware[i];
			} else {
				G[i] = ' ';
			}
		}

		GenSoftware = new String(G);
		return GenSoftware;
	}

	/**
	 * In LAS 1.0 return Julian day
	 * In LAS 1.1 return day of year 1-365
	 *
	 * @return day
	 */
	public int getDay() {
		 return day;
	}

	/**
	 * In LAS 1.0 return year that data was collected
	 * In LAS 1.1 return year on which file was created
	 *
	 * @return year
	 */
	public int getYear() {
		 return year;
	}

	/**
	 * Return Size, in bytes, of the header file
	 *
	 *  @return header size
	 */
	public int getHdrSize() {
		return hdrSize;
	}

	/**
	 * Return Number of bytes from the beginning of the file
	 * to the first point record data (including the two
	 * bytes for data start signature in case of LAS1.0).
	 *
	 * @return offset to data
	 */
	public long getOffsetData() {
		return offsetData;
	}

	/**
	 * Return number of variable length records
	 *
	 * @return number of variable length records
	 */
	public long getNumVarLengthRecord() {
		return numVarLengthRecord;
	}

	/**
	 * Return point data record format type (0-1)
	 *
	 * @return format type.
	 */
	public char getPointDataFormatID() {
		return pointDataFormatID;
	}

	/**
	 * Return size of the point data record
	 *
	 * @return size, in bytes, of the point data.
	 */
	public int getPointDataRecordLength() {
		return pointDataRecordLength;
	}

	/**
	 * Return the total number of points records within the file
	 *
	 * @return number of points of file
	 */
	public long getNumPointsRecord() {

		return numPointsRecord;
	}

	/**
	 * Return array of 5 longs for the point records per return
	 *
	 * @return numPR number of points by return.
	 */
	public void getNumPointsByReturn(long[] numPR) {
		int i=0;
		for(i=0;i<5;i++) {
			numPR[i]= numPointsByReturn[i];
		}
	}

	/**
	 * Return the point records per return of index
	 * if index is between 0 and 5, else return -1
	 *
	 * @param index index to return.
	 * @return number of points by return of index.
	 */
	public long getNumPointsByReturnIndex(int index) {
		if(index < 5) {
			return numPointsByReturn[index];
		} else {
			return -1;
		}
	}

	/**
	 * Return the x scale factor for the scale corresponding X values
	 * within the point record.
	 *
	 * @return X scale
	 */
	public double getXScale() {
		return xScale;
	}

	/**
	 * Return the y scale factor for the scale corresponding Y values
	 * within the point record.
	 *
	 * @return Y scale
	 */
	public double getYScale() {
		return yScale;
	}

	/**
	 * Return the z scale factor for the scale corresponding Z values
	 * within the point record.
	 *
	 * @return Z scale
	 */
	public double getZScale() {
		return zScale;
	}

	/**
	 * Return the x offset used to set the overall offset for the point record
	 * @return X offset
	 */
	public double getXOffset() {
		return xOffset;
	}

	/**
	 * Return the y offset used to set the overall offset for the point record
	 * @return Y offset
	 */
	public double getYOffset() {
		return yOffset;
	}

	/**
	 * Return the z offset used to set the overall offset for the point record
	 * @return Z offset
	 */
	public double getZOffset() {
		return zOffset;
	}

	/**
	 * Return maximum x of coordinate extent of the file.
	 *
	 * @return X max
	 */
	public double getMaxX() {
		return maxX;
	}

	/**
	 * Return minimum x of coordinate extent of the file.
	 *
	 * @return X min
	 */
	public double getMinX() {
		return minX;
	}

	/**
	 * Return maximum y of coordinate extent of the file.
	 *
	 * @return Y max
	 */
	public double getMaxY() {
		return maxY;
	}

	/**
	 * Return minimum y of coordinate extent of the file.
	 *
	 * @return Y min
	 */
	public double getMinY() {
		return minY;
	}

	/**
	 * Return maximum z of coordinate extent of the file.
	 *
	 * @return Z max
	 */
	public double getMaxZ() {
		return maxZ;
	}

	/**
	 * Return minimum z of coordinate extent of the file.
	 *
	 * @return Z min
	 */
	public double getMinZ() {
		return minZ;
	}

	// SETS METHODS
	/**
	 * new Global Unique IDentifier 1
	 *
	 * @param g new value of GUID1
	 */
	public void setGUID1(long g){

		try{
			if(g>=0 && g<=UNSIGNED_INT_MAX) {
				GUID1 = g;
			} else {
				throw new OutOfRangeLidarException("Out of range of GUID1");
			}

		} catch(OutOfRangeLidarException e) {

			e.printStackTrace();
		}
	}

	/**
	 * Set new Global Unique IDentifier 2
	 *
	 * @param g new value of GUID2
	 */
	public void setGUID2(int g){

		try{
			if(g>=0 && g<=UNSIGNED_SHORT_MAX) {
				GUID2 = g;
			} else {
				throw new OutOfRangeLidarException("Out of range of GUID2");
			}

		} catch(OutOfRangeLidarException e) {

			e.printStackTrace();
		}
	}

	/**
	 * Set new Global Unique IDentifier 3
	 *
	 * @param g new value of GUID3
	 */
	public void setGUID3(int g){

		try{
			if(g>=0 && g<=UNSIGNED_SHORT_MAX) {
				GUID3 = g;
			} else {
				throw new OutOfRangeLidarException("Out of range of GUID3");
			}

		} catch(OutOfRangeLidarException e) {

			e.printStackTrace();
		}
	}

	/**
	 * Set new Global Unique IDentifier 4. It must be an array of 8 char
	 *
	 * @param g new value of GUID4
	 */
	public void setGUID4(char[] g){

		if(g.length==8) {
			GUID4 = g;
		}
	}

	/**
	 * Set new Version Mayor
	 *
	 * @param v new value of version mayor
	 */
	public void setVersionMayor(char v){
		versionMayor = v;
	}

	/**
	 * Set new Version Minor
	 *
	 * @param v new value of version minor
	 */
	public void setVersionMinor(char v){
		versionMinor = v;
	}

	/**
	 * Set new systemIDentifier. It must be an array of 32 char
	 *
	 * @param g new value of systemIDentifier
	 */
	public void setSystemIDentifier(char[] s){
		if(s.length==32) {
			systemIDentifier = s;
		}
	}

	/**
	 * Set new generatingSoftware. It must be an array of 32 char
	 *
	 * @param g new value of generatingSoftware
	 */
	public void setGeneratingSoftware(char[] g){
		if(g.length==32) {
			generatingSoftware = g;
		}
	}

	/**
	 * Set new day
	 *
	 * @param newDay new value of day
	 */
	public void setDay(int newDay){

		try{
			if(newDay>=0 && newDay<=UNSIGNED_SHORT_MAX) {
				day = newDay;
			} else {
				throw new OutOfRangeLidarException("Out of range of day");
			}

		} catch(OutOfRangeLidarException e) {

			e.printStackTrace();
		}
	}

	/**
	 * Set new year
	 *
	 * @param newYear new value of year
	 */
	public void setYear(int newYear){

		try{
			if(newYear>=0 && newYear<=UNSIGNED_SHORT_MAX) {
				year = newYear;
			} else {
				throw new OutOfRangeLidarException("Out of range of year");
			}

		} catch(OutOfRangeLidarException e) {

			e.printStackTrace();
		}
	}

	/**
	 * Set new point data format ID
	 *
	 * @param pointFormatID new value of point data format ID
	 */
	public void SetPointDataFormatID(char pointFormatID){

		pointDataFormatID = pointFormatID;
	}

	/**
	 * Set new point data record length
	 *
	 * @param pointLength new value of point data record length
	 */
	public void SetPointDataRecordLength(int pointLength){

		try{
			if(pointLength>=0 && pointLength <=UNSIGNED_SHORT_MAX) {
				pointDataRecordLength = pointLength;
			} else {
				throw new OutOfRangeLidarException("Out of range of data record legnth");
			}

		} catch(OutOfRangeLidarException e) {

			e.printStackTrace();
		}
	}

	/**
	 * Set array of the 5 longs for point records per return.
	 *
	 * Make sure that all values are between 0 and (2^32)-1 or value
	 * will be set to 0.
	 *
	 * @return numPR number of points by return.
	 */
	public void setNumPointsByReturn(long[] numPR) {
		int i=0;
		for(i=0;i<5;i++) {
			if(numPR[i]>=0 && numPR[i] < UNSIGNED_INT_MAX) {
				numPointsByReturn[i] = numPR[i];
			} else {
				numPointsByReturn[i]=0;
			}
		}
	}

	public void setHdrSize(int newValue) {

		try{
			if(newValue>=0 && newValue<=UNSIGNED_SHORT_MAX) {
				hdrSize = newValue;
			} else {
				throw new OutOfRangeLidarException("Out of range of header size");
			}

		} catch(OutOfRangeLidarException e) {

			e.printStackTrace();
		}
	}

	public void setMaxX(double newValue) {
		maxX = newValue;
	}

	public void setMaxY(double newValue) {
		maxY = newValue;
	}

	public void setMaxZ(double newValue) {
		maxZ = newValue;
	}

	public void setMinX(double newValue) {
		minX = newValue;
	}

	public void setMinY(double newValue) {
		minY = newValue;
	}

	public void setMinZ(double newValue) {
		minZ = newValue;
	}

	public void setXOffset(double newValue) {
		xOffset = newValue;
	}

	public void setXScale(double newValue) {
		xScale = newValue;
	}

	public void setYOffset(double newValue) {
		yOffset = newValue;
	}

	public void setYScale(double newValue) {
		yScale = newValue;
	}

	public void setZOffset(double newValue) {
		zOffset = newValue;
	}

	public void setZScale(double newValue) {
		zScale = newValue;
	}

	public void setNumPointsRecord(long newValue) {

		try{
			if(newValue>=0 && newValue <= UNSIGNED_INT_MAX) {
				numPointsRecord = newValue;
			} else {
				throw new OutOfRangeLidarException("Out of range of num points record");
			}

		} catch(OutOfRangeLidarException e) {

			e.printStackTrace();
		}
	}

	public void setOffsetData(long newValue) {

		try{
			if(newValue>=0 && newValue <= UNSIGNED_INT_MAX) {
				offsetData = newValue;
			} else {
				throw new OutOfRangeLidarException("Out of range of offset data");
			}

		} catch(OutOfRangeLidarException e) {

			e.printStackTrace();
		}
	}

	/**
	 * set number of variable length records
	 *
	 * @param n number of variable length records
	 */
	protected void setNumVarLengthRecord(long n) {

		try{
			if(n>=0 && n <= UNSIGNED_INT_MAX) {
				numVarLengthRecord = n;
			} else {
				throw new OutOfRangeLidarException("Out of range of number of variable length record");
			}

		} catch(OutOfRangeLidarException e) {

			e.printStackTrace();
		}
	}

	/**
	 * get vector of Variable length record
	 *
	 * @return vector of Variable length record
	 */
	public abstract LASVariableLengthRecord_1X[] getLASHeaderVLR();

	/**
	 * get Variable length record of given index
	 *
	 * @param i index of VLR
	 * @return Variable length record of index
	 */
	public abstract LASVariableLengthRecord_1X getLASHeaderVLRByIndex(long i);

	/**
	 * set new Variable length record
	 *
	 * @param l new vector of Variable length record
	 */
	public abstract void setLASHeaderVLR(LASVariableLengthRecord_1X[] v);


    public static void copyFile(FileChannel fcin, FileChannel fcout)
			throws IOException {

		// Esto antes tenía un problema de que solo copiaba
		// los primeros 100 KBytes. Ahora le hemos puesto
		// un while y hemos comprobado que copia todo el fichero.
		// Ole tus huevos Luis, que tenga que comentar esto
		// y ver cómo está el resto del código.
		ByteBuffer buffer = ByteBuffer.allocate(102400);
		buffer.clear();
		int r = 0;
		int position = 0;
		while ((r = fcin.read(buffer, position)) != -1) {
			buffer.flip();
			int bytesWritten = fcout.write(buffer, position);
			position += bytesWritten;
			buffer.clear();
		}
	}

}
