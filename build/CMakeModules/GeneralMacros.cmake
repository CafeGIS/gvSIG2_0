MACRO(CONFIGURE_DEFAULTS)
    # Looking for arch extension!
    SET(LIB_POSTFIX "32")
    IF(UNIX)
	    IF(NOT APPLE)
		    IF(CMAKE_SIZEOF_VOID_P MATCHES "8")
      		    SET(LIB_POSTFIX "64")
  		    ENDIF(CMAKE_SIZEOF_VOID_P MATCHES "8")
	    ENDIF(NOT APPLE)
    ELSE(UNIX)
	    IF(CMAKE_SYSTEM_NAME MATCHES Windows)
		    IF(CMAKE_CL_64)
      		    SET(LIB_POSTFIX "64")
		    ENDIF(CMAKE_CL_64)	
	    ENDIF(CMAKE_SYSTEM_NAME MATCHES Windows)
    ENDIF(UNIX)
	# This is for an advanced option to give aggressive warnings
	# under different compilers. If yours is not implemented, this option
	# will not be made available.
	IF(CMAKE_COMPILER_IS_GNUCXX)
	    # To be complete, we might also do GNUCC flags,
	    # but everything here is C++ code.
	    # -Wshadow and -Woverloaded-virtual are also interesting flags, but OSG
	    # returns too many hits.
	    # FYI, if we do implement GNUCC, then -Wmissing-prototypes in another
	    # interesting C-specific flag.
	    # Also, there is a bug in gcc 4.0. Under C++, -pedantic will create
	    # errors instead of warnings for certain issues, including superfluous
	    # semicolons and commas, and the use of long long. -fpermissive seems
	    # to be the workaround.
	    SET(AGGRESSIVE_WARNING_FLAGS "-Wall -Wparentheses -Wformat=2 -Wno-long-long -Wno-import -pedantic -Wreturn-type -Wmissing-braces -Wunknown-pragmas -Wunused")
		IF(NOT APPLE)
			SET(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} "-fpermissive")
		ENDIF(NOT APPLE)
	ELSE(CMAKE_COMPILER_IS_GNUCXX)
	    IF(MSVC)
	        # FIXME: What are good aggressive warning flags for Visual Studio?
	        # And do we need to further subcase this for different versions of VS?
	        # CMake variables: MSVC60, MSVC70, MSVC71, MSVC80, CMAKE_COMPILER_2005
	        SET(AGGRESSIVE_WARNING_FLAGS "/Wall /W4")


	    ELSE(MSVC)
	        # CMake lacks an elseif, so other non-gcc, non-VS compilers need
	        # to be listed below. If unhandled, OSG_AGGRESSIVE_WARNING_FLAGS should
	        # remain unset.
	    ENDIF(MSVC)
	ENDIF(CMAKE_COMPILER_IS_GNUCXX)

	# This part is for the CMake menu option to toggle the warnings on/off.
	# This will only be made available if we set values for OSG_AGGRESSIVE_WARNING_FLAGS.
	IF(AGGRESSIVE_WARNING_FLAGS)
	    OPTION(USE_AGGRESSIVE_WARNINGS "Enable to activate aggressive warnings" OFF)
	    MARK_AS_ADVANCED(USE_AGGRESSIVE_WARNINGS)

	    IF(USE_AGGRESSIVE_WARNINGS)
	        IF(NOT "${OLD_CMAKE_CXX_FLAGS_WAS_SET}")
	            SET(OLD_CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}" CACHE INTERNAL "Old CXX flags")
	            SET(OLD_CMAKE_CXX_FLAGS_WAS_SET 1 CACHE INTERNAL "Old CXX flags was set")
	            SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${AGGRESSIVE_WARNING_FLAGS}" CACHE STRING "Flags used by the compiler during all build types." FORCE)
	        ENDIF(NOT "${OLD_CMAKE_CXX_FLAGS_WAS_SET}")
	    ELSE(USE_AGGRESSIVE_WARNINGS)
	        # FIXME: This will lose any changes made after OLD_CMAKE_CXX_FLAGS was
	        # set. The better way would be to parse the string and remove each
	        # option explicitly.
	        IF("${OLD_CMAKE_CXX_FLAGS_WAS_SET}")
	            SET(CMAKE_CXX_FLAGS "${OLD_CMAKE_CXX_FLAGS}" CACHE STRING "Flags used by the compiler during all build types." FORCE)
	            SET(OLD_CMAKE_CXX_FLAGS_WAS_SET 0 CACHE INTERNAL "Old CXX flags was set")
	        ENDIF("${OLD_CMAKE_CXX_FLAGS_WAS_SET}")
	    ENDIF(USE_AGGRESSIVE_WARNINGS)
	ENDIF(AGGRESSIVE_WARNING_FLAGS)

	# Set defaults for Universal Binaries. We want 32-bit Intel/PPC on 10.4
	# and 32/64-bit Intel/PPC on >= 10.5. Anything <= 10.3 doesn't support.
	IF(APPLE)
	    # These are just defaults/recommendations, but how we want to build
	    # out of the box. But the user needs to be able to change these options.
	    # So we must only set the values the first time CMake is run, or we
	    # will overwrite any changes the user sets.
	    # FORCE is used because the options are not reflected in the UI otherwise.
	    # Seems like a good place to add version specific compiler flags too.
	    IF(NOT CONFIG_HAS_BEEN_RUN_BEFORE)
	        # This is really fragile, but CMake doesn't provide the OS system
	        # version information we need. (Darwin versions can be changed
	        # independently of OS X versions.)
	        # It does look like CMake handles the CMAKE_OSX_SYSROOT automatically.
	        IF(EXISTS /Developer/SDKs/MacOSX10.5.sdk)
	            #SET(CMAKE_OSX_ARCHITECTURES "ppc;i386;ppc64;x86_64" CACHE STRING "Build architectures for OSX")
				SET(CMAKE_OSX_ARCHITECTURES "ppc;i386" CACHE STRING "Build architectures for OSX")
	            SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mmacosx-version-min=10.5 -ftree-vectorize -fvisibility-inlines-hidden" CACHE STRING "Flags used by the compiler during all build types." FORCE)
	        ELSE(EXISTS /Developer/SDKs/MacOSX10.5.sdk)
	            IF(EXISTS /Developer/SDKs/MacOSX10.4u.sdk)
	                SET(CMAKE_OSX_ARCHITECTURES "ppc;i386" CACHE STRING "Build architectures for OSX" FORCE)
	                SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mmacosx-version-min=10.4 -ftree-vectorize -fvisibility-inlines-hidden" CACHE STRING "Flags used by the compiler during all build types." FORCE)
	            ELSE(EXISTS /Developer/SDKs/MacOSX10.4u.sdk)
	                # No Universal Binary support
	                # Should break down further to set the -mmacosx-version-min,
	                # but the SDK detection is too unreliable here.
	            ENDIF(EXISTS /Developer/SDKs/MacOSX10.4u.sdk)
	        ENDIF(EXISTS /Developer/SDKs/MacOSX10.5.sdk)
	    ENDIF(NOT CONFIG_HAS_BEEN_RUN_BEFORE)
    	SET(CMAKE_INSTALL_NAME_DIR @executable_path/../Resources/NativeLibs CACHE STRING "Executable Path for MacOS X" FORCE)
	    MARK_AS_ADVANCED(CMAKE_INSTALL_NAME_DIR)
	ENDIF(APPLE)
	
	SET(OUTPUT_BINDIR ${CMAKE_BINARY_DIR}/bin)
	MAKE_DIRECTORY(${OUTPUT_BINDIR})

	SET(OUTPUT_LIBDIR ${CMAKE_BINARY_DIR}/lib)
	MAKE_DIRECTORY(${OUTPUT_LIBDIR})
	IF(CMAKE_MAJOR_VERSION EQUAL 2 AND CMAKE_MINOR_VERSION GREATER 4)
	    # If CMake >= 2.6.0
	    SET(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${OUTPUT_LIBDIR})
	    SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${OUTPUT_BINDIR})
	    IF(WIN32)
	        SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${OUTPUT_BINDIR})
	    ELSE(WIN32)
	        SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${OUTPUT_LIBDIR})
	    ENDIF(WIN32)
	ELSE(CMAKE_MAJOR_VERSION EQUAL 2 AND CMAKE_MINOR_VERSION GREATER 4)
	    SET(EXECUTABLE_OUTPUT_PATH ${OUTPUT_BINDIR})
	    SET(LIBRARY_OUTPUT_PATH ${OUTPUT_LIBDIR})
	ENDIF(CMAKE_MAJOR_VERSION EQUAL 2 AND CMAKE_MINOR_VERSION GREATER 4)
	
ENDMACRO(CONFIGURE_DEFAULTS)

MACRO(CONFIGURE_END)
	# This needs to be run very last so other parts of the scripts can take
	# advantage of this.
	IF(NOT CONFIG_HAS_BEEN_RUN_BEFORE)
	    SET(CONFIG_HAS_BEEN_RUN_BEFORE 1 CACHE INTERNAL "Flag to track whether this is the first time running CMake or if CMake has been configured before")
	ENDIF(NOT CONFIG_HAS_BEEN_RUN_BEFORE)
ENDMACRO(CONFIGURE_END)

MACRO(SETUP_CORELIB CORELIB_NAME)
	IF(COMPILE_STATIC)
		ADD_LIBRARY(${CORELIB_NAME}
			STATIC
			${HEADERS}
			${SOURCES}
		)
	ELSE(COMPILE_STATIC)
		ADD_LIBRARY(${CORELIB_NAME}
			SHARED
			${HEADERS}
			${SOURCES}
		)
	ENDIF(COMPILE_STATIC)

	TARGET_LINK_LIBRARIES(${CORELIB_NAME} ${LIBRARIES})

	IF(LIBRARIES_OPTIMIZED)
		FOREACH(LIBOPT ${LIBRARIES_OPTIMIZED})
			TARGET_LINK_LIBRARIES(${CORELIB_NAME} optimized ${LIBOPT})
		ENDFOREACH(LIBOPT)
	ENDIF(LIBRARIES_OPTIMIZED)

	IF(LIBRARIES_DEBUG)
		FOREACH(LIBDEBUG ${LIBRARIES_DEBUG})
			TARGET_LINK_LIBRARIES(${CORELIB_NAME} debug ${LIBDEBUG})
		ENDFOREACH(LIBDEBUG)
	ENDIF(LIBRARIES_DEBUG)

	SET_TARGET_PROPERTIES(${CORELIB_NAME}
		PROPERTIES
		PROJECT_LABEL "Core ${CORELIB_NAME}"
	)
	IF(WIN32)
		INSTALL(TARGETS ${CORELIB_NAME}
			RUNTIME DESTINATION bin
			ARCHIVE DESTINATION lib
		)
	ELSE(WIN32)
		INSTALL(TARGETS ${CORELIB_NAME}
			LIBRARY DESTINATION lib
			ARCHIVE DESTINATION lib
		)
	ENDIF(WIN32)
	
	IF(UNIX AND NOT APPLE)
		SET_TARGET_PROPERTIES ( ${CORELIB_NAME} PROPERTIES LINK_FLAGS "-Wl,-E")
	ENDIF(UNIX AND NOT APPLE)

	IF(VERSION)
		#SET_TARGET_PROPERTIES(${CORELIB_NAME} PROPERTIES VERSION "${VERSION}")
		SET_TARGET_PROPERTIES(${LIB_NAME} PROPERTIES OUTPUT_NAME "${CORELIB_NAME}${VERSION}")
	ENDIF(VERSION)

ENDMACRO(SETUP_CORELIB)

MACRO(SETUP_JNILIB JNILIB_NAME)

	ADD_LIBRARY(${JNILIB_NAME}
		SHARED
		${HEADERS}
		${SOURCES}
	)

	TARGET_LINK_LIBRARIES(${JNILIB_NAME} ${LIBRARIES})

	IF(LIBRARIES_OPTIMIZED)
		FOREACH(LIBOPT ${LIBRARIES_OPTIMIZED})
			TARGET_LINK_LIBRARIES(${JNILIB_NAME} optimized ${LIBOPT})
		ENDFOREACH(LIBOPT)
	ENDIF(LIBRARIES_OPTIMIZED)

	IF(LIBRARIES_DEBUG)
		FOREACH(LIBDEBUG ${LIBRARIES_DEBUG})
			TARGET_LINK_LIBRARIES(${JNILIB_NAME} debug ${LIBDEBUG})
		ENDFOREACH(LIBDEBUG)
	ENDIF(LIBRARIES_DEBUG)
	
	IF(APPLE)
		SET_TARGET_PROPERTIES(${JNILIB_NAME}
    	PROPERTIES
    	SUFFIX .jnilib)
	ENDIF(APPLE)
	

	SET_TARGET_PROPERTIES(${JNILIB_NAME}
		PROPERTIES
		PROJECT_LABEL "JNI ${JNILIB_NAME}"
	)

	IF(WIN32)
		INSTALL(TARGETS ${JNILIB_NAME}
			RUNTIME DESTINATION bin
			ARCHIVE DESTINATION lib
		)
	ELSE(WIN32)
		INSTALL(TARGETS ${JNILIB_NAME}
			LIBRARY DESTINATION lib
		)
	ENDIF(WIN32)
	
	IF(UNIX AND NOT APPLE)
		SET_TARGET_PROPERTIES (${JNILIB_NAME} PROPERTIES LINK_FLAGS "-Wl,-E")
	ENDIF(UNIX AND NOT APPLE)
	
	IF(VERSION)
		#SET_TARGET_PROPERTIES(${CORELIB_NAME} PROPERTIES VERSION "${VERSION}")
		SET_TARGET_PROPERTIES(${LIB_NAME} PROPERTIES OUTPUT_NAME "${JNILIB_NAME}${VERSION}")
	ENDIF(VERSION)
	
ENDMACRO(SETUP_JNILIB)

MACRO(SETUP_EXECUTABLE EXECUTABLE_NAME)

	IF(IS_APPLICATION)
		IF(APPLE)
		    # SET(MACOSX_BUNDLE_LONG_VERSION_STRING "${CRSFX_MAJOR_VERSION}.${CRSFX_MINOR_VERSION}.${CRSFXCRSFX_PATCH_VERSION}")
		    # Short Version is the "marketing version". It is the version
		    # the user sees in an information panel.
		    SET(MACOSX_BUNDLE_SHORT_VERSION_STRING "${VERSION}")
		    # Bundle version is the version the OS looks at.
		    SET(MACOSX_BUNDLE_BUNDLE_VERSION "${VERSION}")
		    SET(MACOSX_BUNDLE_GUI_IDENTIFIER "${EXECUTABLE_NAME}" )
		    SET(MACOSX_BUNDLE_BUNDLE_NAME "${EXECUTABLE_NAME}" )
		    # SET(MACOSX_BUNDLE_ICON_FILE "myicon.icns")
		    # SET(MACOSX_BUNDLE_COPYRIGHT "")
		    # SET(MACOSX_BUNDLE_INFO_STRING "Info string, localized?")
			SET(PLATFORM_SPECIFIC_CONTROL MACOSX_BUNDLE)
		ENDIF(APPLE)

		IF(WIN32)
		    IF (REQUIRE_WINMAIN_FLAG)
		        SET(PLATFORM_SPECIFIC_CONTROL WIN32)
		    ENDIF(REQUIRE_WINMAIN_FLAG)
		ENDIF(WIN32)
	
		ADD_EXECUTABLE(${EXECUTABLE_NAME} ${PLATFORM_SPECIFIC_CONTROL} ${SOURCES} ${HEADERS})
		IF(APPLE AND INSTALL_DEPENDENCIES)
		    SETUP_BUNDLE_DEPENDENCIES(${EXECUTABLE_NAME})
		ENDIF(APPLE AND INSTALL_DEPENDENCIES)
	ELSE(IS_APPLICATION)
		ADD_EXECUTABLE(${EXECTUABLE_NAME} ${SOURCES} ${HEADERS})
	ENDIF(IS_APPLICATION)

	TARGET_LINK_LIBRARIES(${EXECUTABLE_NAME} ${LIBRARIES})
	IF(LIBRARIES_OPTIMIZED)
		FOREACH(LIBOPT ${LIBRARIES_OPTIMIZED})
			TARGET_LINK_LIBRARIES(${EXECUTABLE_NAME} optimized ${LIBOPT})
		ENDFOREACH(LIBOPT)
	ENDIF(LIBRARIES_OPTIMIZED)

	IF(LIBRARIES_DEBUG)
		FOREACH(LIBDEBUG ${LIBRARIES_DEBUG})
			TARGET_LINK_LIBRARIES(${EXECUTABLE_NAME} debug ${LIBDEBUG})
		ENDFOREACH(LIBDEBUG)
	ENDIF(LIBRARIES_DEBUG)

	SET_TARGET_PROPERTIES(${EXECUTABLE_NAME} PROPERTIES PROJECT_LABEL "Application ${EXECUTABLE_NAME}")
	
	IF(APPLE)
		INSTALL(TARGETS ${EXECUTABLE_NAME}
			RUNTIME DESTINATION bin
			BUNDLE DESTINATION bin
		)
	ELSE(APPLE)
		INSTALL(TARGETS ${EXECUTABLE_NAME}
			RUNTIME DESTINATION bin
			COMPONENT DESTINATION bin
		)
	ENDIF(APPLE)

ENDMACRO(SETUP_EXECUTABLE)


MACRO(SETUP_BUNDLE_DEPENDENCIES TARGET_NAME)
	IF(DEPENDENCY_FILES)
		IF(APPLE AND IS_APPLICATION)
			INSTALL(PROGRAMS ${DEPENDENCY_FILES}
				DESTINATION bin/${TARGET_NAME}.app/Contents/MacOS
			)
		ENDIF(APPLE AND IS_APPLICATION)
	ENDIF(DEPENDENCY_FILES)
	
	IF(DEPENDENCY_DIRS)
		IF(APPLE AND IS_APPLICATION)
			INSTALL(DIRECTORY ${DEPENDENCY_DIRS}		
					DESTINATION bin/${TARGET_NAME}.app/Contents/Resources
					PATTERN ".svn" EXCLUDE)
		ENDIF(APPLE AND IS_APPLICATION)
	ENDIF(DEPENDENCY_DIRS)

	IF(RESOURCE_FILES)
		IF(APPLE AND IS_APPLICATION)
			INSTALL(FILES ${RESOURCE_FILES}
		        	DESTINATION bin/${TARGET_NAME}.app/Contents/Resources
			)
		ENDIF(APPLE AND IS_APPLICATION)
	ENDIF(RESOURCE_FILES)

	IF(RESOURCE_DIRS)
		IF(APPLE AND IS_APPLICATION)
			INSTALL(DIRECTORY ${RESOURCE_DIRS}		
					DESTINATION bin/${TARGET_NAME}.app/Contents/Resources
					PATTERN ".svn" EXCLUDE
					)
		ENDIF(APPLE AND IS_APPLICATION)
	ENDIF(RESOURCE_DIRS)
	
ENDMACRO(SETUP_BUNDLE_DEPENDENCIES TARGET_NAME)

MACRO(SETUP_DEPENDENCIES)
	IF(DEPENDENCY_FILES)
		IF(WIN32)
			INSTALL(PROGRAMS ${DEPENDENCY_FILES}
				DESTINATION bin
			)
		ELSE(WIN32)
		    INSTALL(PROGRAMS ${DEPENDENCY_FILES}
			    DESTINATION lib
			)
		ENDIF(WIN32)
	ENDIF(DEPENDENCY_FILES)
	
	IF(DEPENDENCY_DIRS)
        IF(WIN32)
    	    INSTALL(DIRECTORY ${DEPENDENCY_DIRS}		
    				DESTINATION bin
    				PATTERN ".svn" EXCLUDE
    				PATTERN ".cache" EXCLUDE)
    	ELSE(WIN32)
    	    INSTALL(DIRECTORY ${DEPENDENCY_DIRS}		
    				DESTINATION lib
    				PATTERN ".svn" EXCLUDE
    				PATTERN ".cache" EXCLUDE)		
		ENDIF(WIN32)
	ENDIF(DEPENDENCY_DIRS)

	IF(RESOURCE_FILES)
		INSTALL(FILES ${RESOURCE_FILES}
		       	DESTINATION share/${CMAKE_PROJECT_NAME}/resources
		)
	ENDIF(RESOURCE_FILES)

	IF(RESOURCE_DIRS)
		INSTALL(DIRECTORY ${RESOURCE_DIRS}		
				DESTINATION share/${CMAKE_PROJECT_NAME}/resources
				PATTERN ".svn" EXCLUDE
		)
	ENDIF(RESOURCE_DIRS)
	
	IF(SCRIPT_FILES)
		INSTALL(PROGRAMS ${SCRIPT_FILES}
				DESTINATION .
				PERMISSIONS OWNER_WRITE OWNER_READ OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE
		)
	ENDIF(SCRIPT_FILES)
ENDMACRO(SETUP_DEPENDENCIES)


